#define SERVICE_UUID        "73cfa67c-c85a-45ae-af51-329641b8f315"
#define CHARACTERISTIC_UUID "ded8cb86-dd30-4f11-b39c-68f15f2a2f90"



BLEDevice::init("NeoRCP");





// ESP32 - Arduino IDE
// Enviar texto por BLE (UTF-8) vía NOTIFY, líneas separadas por '\n'

#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>

// ==== UUIDs (deben coincidir con tu app Flutter Web) ====
#define SERVICE_UUID        "12345678-1234-1234-1234-123456789abc"
#define CHAR_TEXT_UUID      "87654321-4321-4321-4321-cba987654321"
// =========================================================

BLEServer* pServer = nullptr;
BLECharacteristic* pTextChar = nullptr;
BLE2902* pTextCccd = nullptr;

volatile bool deviceConnected = false;

class ServerCallbacks : public BLEServerCallbacks {
  void onConnect(BLEServer* s) override {
    deviceConnected = true;
    // En Web Bluetooth, MTU lo maneja el browser; no hace falta cambiar nada acá
    Serial.println("[BLE] Central conectado");
  }
  void onDisconnect(BLEServer* s) override {
    deviceConnected = false;
    Serial.println("[BLE] Central desconectado");
    // Reanunciar para permitir reconexión
    s->getAdvertising()->start();
  }
};

void setup() {
  Serial.begin(115200);
  delay(200);

  // Nombre visible del dispositivo (el que vas a ver en el diálogo del navegador)
  BLEDevice::init("NeoRCP");

  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new ServerCallbacks());

  // Servicio principal
  BLEService* pService = pServer->createService(SERVICE_UUID);

  // Característica de texto: NOTIFY (+READ opcional por si querés ver el último valor)
  pTextChar = pService->createCharacteristic(
    CHAR_TEXT_UUID,
    BLECharacteristic::PROPERTY_NOTIFY | BLECharacteristic::PROPERTY_READ
  );

  // Descriptor CCCD 0x2902 para habilitar notificaciones desde el cliente
  pTextCccd = new BLE2902();
  pTextCccd->setNotifications(false);  // arranca deshabilitado
  pTextChar->addDescriptor(pTextCccd);

  pService->start();

  // Anunciar incluyendo el UUID del servicio (importante para que lo descubra el cliente)
  BLEAdvertising* pAdv = BLEDevice::getAdvertising();
  pAdv->addServiceUUID(SERVICE_UUID);
  pAdv->setScanResponse(true);
  pAdv->setMinPreferred(0x06);  // parámetros estándar
  pAdv->setMinPreferred(0x12);
  BLEDevice::startAdvertising();

  Serial.println("[BLE] Listo. Anunciando servicio...");
}

void loop() {
  static uint32_t t0 = 0;
  const uint32_t PERIOD_MS = 500;

  if (millis() - t0 >= PERIOD_MS) {
    t0 = millis();

    // Solo notificar si hay central conectada Y notificaciones habilitadas (CCCD)
    // Nota: getNotifications() = true si el cliente habilitó notify en 0x2902
    const bool subscribed = pTextCccd->getNotifications();

    if (deviceConnected && subscribed) {
      // Construimos una línea de texto (UTF-8) y terminamos en '\n'
      String line = "NeoRCP t=" + String(millis()) + " ms\n";
      // Enviar
      pTextChar->setValue((uint8_t*)line.c_str(), line.length());
      pTextChar->notify();
      // (Opcional) mantener valor legible via READ
      // pTextChar->setValue(...) ya lo deja como último valor leído
      Serial.print("[BLE] TX: "); Serial.print(line);
    }
  }

  // No bloquees el loop; BLE corre en background
}
